 /*

  * Lecensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */

package alma.STOPWATCH_MODULE.StopWatchImpl;

import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;
import java.util.List;
import java.util.ArrayList;
import java.util.logging.Logger;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;

import alma.ACS.*;
import alma.acs.component.ComponentLifecycle;
import alma.acs.component.ComponentLifecycleException;
import alma.acs.container.ContainerServices;
import alma.ACSErr.CompletionHolder;
import alma.acs.callbacks.*;
import alma.STOPWATCH_MODULE.StopWatchOperations;

import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.apache.commons.scxml.model.CustomAction;
import org.apache.commons.scxml.model.TransitionTarget;
import org.apache.commons.scxml.model.Transition;
import org.apache.commons.scxml.model.ModelException;
import org.apache.commons.scxml.model.SCXML;
import org.apache.commons.scxml.SCXMLExecutor;
import org.apache.commons.scxml.SCXMLListener;
import org.apache.commons.scxml.TriggerEvent;
import org.apache.commons.scxml.io.SCXMLParser;
import org.apache.commons.scxml.Context;
import org.apache.commons.scxml.Evaluator;
import org.apache.commons.scxml.TriggerEvent;
import org.apache.commons.scxml.env.AbstractStateMachine;
import org.apache.commons.scxml.env.jexl.JexlContext;
import org.apache.commons.scxml.env.jexl.JexlEvaluator;
import org.apache.commons.scxml.env.SimpleDispatcher;
import org.apache.commons.scxml.env.SimpleErrorReporter;
import org.apache.commons.scxml.env.SimpleSCXMLListener;
import org.apache.commons.digester.Digester; 
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.scxml.env.URLResolver;
import org.apache.commons.scxml.invoke.SimpleSCXMLInvoker;

/**
 * A SCXML document driven stop watch.
 *
 * Using SCXML makes the StopWatch class simplistic; you are neither
 * managing the stopwatch "lifecycle" nor coding any "transitions",
 * that information is pulled in straight from the behavioral model
 * of the stop watch, which is encapsulated in the SCXML document
 * the constructor points to (which in turn may be generated straight
 * from the UML model).
 */

public class StopWatchImpl implements StopWatchOperations, ComponentLifecycle, Runnable
{
    /////////////////////////////////////////////////////////////
    // State Machine Apache Commons SCXML variables
    /////////////////////////////////////////////////////////////

    private ErrorHandler errorHandler;
    // The state machine that will drive the instances of this class.
    private SCXML scxml = null;
    // The instance specific SCXML engine.
    private SCXMLExecutor engine;

    private Digester digester;

    private SimpleSCXMLListener listener = new SimpleSCXMLListener();

    // The log
    private Log log;
    // The method signature for the activities corresponding to each state in the SCXML document.
    private static final Class[] SIGNATURE = new Class[0];
    //The method parameters for the activities corresponding to each state in the SCXML document.
    private static final Object[] PARAMETERS = new Object[0];

    private URL urlsc;

    /////////////////////////////////////////////////////////////
    // ACS component variables
    /////////////////////////////////////////////////////////////

    private ContainerServices _containerServices;
    private Logger _logger;

    /////////////////////////////////////////////////////////////
    // Implementation of StateMachine
    /////////////////////////////////////////////////////////////

     public StopWatchImpl(){
	log = LogFactory.getLog(this.getClass());
	setUpStateMachine();
    }
 
    /**
    * Instantiate and initialize the underlying executor instance.
    *
    * @param stateMachine The state machine
    * @param rootCtx The root context
    * @param evaluator The expression evaluator
    */

    private void setUpStateMachine() {
        /** Creation of custom Actions */
        CustomAction ca1 = new CustomAction("http://my.custom-actions.domain/CUSTOM1", "resetDisplay", ResetDisplay.class);
        CustomAction ca2 = new CustomAction("http://my.custom-actions.domain/CUSTOM2", "freezeDisplay", FreezeDisplay.class);
        CustomAction ca3 = new CustomAction("http://my.custom-actions.domain/CUSTOM3", "stopTimer", StopTimer.class);
        List <CustomAction> customActions = new ArrayList <CustomAction> ();
        customActions.add(ca1);
        customActions.add(ca2);
        customActions.add(ca3);

        urlsc = this.getClass().getClassLoader().getResource("alma/STOPWATCH_MODULE/StopWatchImpl/config/stopwatch.xml");
        try {
            scxml = SCXMLParser.parse(urlsc, errorHandler, customActions);
            }
        catch (IOException ioe) {
            logError(ioe);
        } catch (SAXException sae) {
            logError(sae);
        } catch (ModelException me) {
            logError(me);
        } catch (Exception e) {
        }
    }

    private void initializeStateMachine(final SCXML stateMachine, final Context rootCtx, final Evaluator evaluator) {
  	    engine = new SCXMLExecutor(evaluator, new SimpleDispatcher(), new SimpleErrorReporter());
            engine.setStateMachine(stateMachine);
            engine.setSuperStep(true);
	    rootCtx.set("containerServices", (ContainerServices) _containerServices);
	    rootCtx.set("logger", (Logger) _logger);
            engine.setRootContext(rootCtx);
            engine.addListener(stateMachine, listener);
	    engine.registerInvokerClass("java", JavaInvoker.class);
	    try {
                engine.go();
            } catch (ModelException me) {
            } catch (Exception e){
             e.printStackTrace();
            }
    }

    /**
    * Utility method for logging error.
    *
    * @param exception The exception leading to this error condition.
    */
    protected void logError(final Exception exception) {
        if (log.isErrorEnabled()) {
            log.error(exception.getMessage(), exception);
        }
    }

    /////////////////////////////////////////////////////////////
    // Implementation of ComponentLifecycle
    /////////////////////////////////////////////////////////////
    
    public void initialize(ContainerServices containerServices) throws ComponentLifecycleException {
            _containerServices = containerServices;
            _logger = _containerServices.getLogger();
            _logger.info("initialize() called...");
    }
    
    public void execute() {
	    
            _logger.info("execute() called...");
            initializeStateMachine(scxml, new JexlContext(), new JexlEvaluator());
    }
    
    public void cleanUp() {
            _logger.info("cleanUp() called");
    }
    
    public void aboutToAbort() {
            cleanUp();
            _logger.info("managed to abort...");
    }

    /////////////////////////////////////////////////////////////
    // Implementation of ACSComponent
    /////////////////////////////////////////////////////////////
    
    public ComponentStates componentState() {
    	return _containerServices.getComponentStateManager().getCurrentState();
    }
    public String name() {
    	return _containerServices.getName();
    }

    public void run() {
	_logger.info("run...");
    }

    /////////////////////////////////////////////////////////////
    // CORBA Call Methods (defined in IDL)
    /////////////////////////////////////////////////////////////

    public String getDisplay() {
          return ((StartTimer) engine.getRootContext().get("tictac")).getDisplay();
    }

    // used by the demonstration (see StopWatchDisplay usecase)
    public String getCurrentState() {
        Set states = engine.getCurrentStatus().getStates();
        return ((org.apache.commons.scxml.model.State) states.iterator().next()).getId();
    }


    public boolean fireEvent(final String event) {
         TriggerEvent[] evts = {new TriggerEvent(event, TriggerEvent.SIGNAL_EVENT, null)};
         try {
             engine.triggerEvents(evts);
         } catch (ModelException me) {
             logError(me);
         }
         return engine.getCurrentStatus().isFinal();
     }


    public boolean start() {
         TriggerEvent[] evts = {new TriggerEvent("watch.start", TriggerEvent.SIGNAL_EVENT, null)};
         try {
             engine.triggerEvents(evts);
         } catch (ModelException me) {
             logError(me);
         }
         return engine.getCurrentStatus().isFinal();
     }

    public boolean stop() {
         TriggerEvent[] evts = {new TriggerEvent("watch.stop", TriggerEvent.SIGNAL_EVENT, null)};
         try {
             engine.triggerEvents(evts);
         } catch (ModelException me) {
             logError(me);
         }
         return engine.getCurrentStatus().isFinal();
     }

    public boolean split() {
         TriggerEvent[] evts = {new TriggerEvent("watch.split", TriggerEvent.SIGNAL_EVENT, null)};
         try {
             engine.triggerEvents(evts);
         } catch (ModelException me) {
             logError(me);
         }
         return engine.getCurrentStatus().isFinal();
     }

     public boolean unsplit() {
         TriggerEvent[] evts = {new TriggerEvent("watch.unsplit", TriggerEvent.SIGNAL_EVENT, null)};
         try {
             engine.triggerEvents(evts);
         } catch (ModelException me) {
             logError(me);
         }
         return engine.getCurrentStatus().isFinal();
     }

     public boolean reset() {
         TriggerEvent[] evts = {new TriggerEvent("watch.reset", TriggerEvent.SIGNAL_EVENT, null)};
         try {
             engine.triggerEvents(evts);
         } catch (ModelException me) {
             logError(me);
         }
         return engine.getCurrentStatus().isFinal();
     }



}
