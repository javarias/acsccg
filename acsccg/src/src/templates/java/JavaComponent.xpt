«IMPORT uml»
«IMPORT JavaInheritanceOverride»
«IMPORT JavaInheritanceAllOverride»
«IMPORT JavaInterfaceImplements»
«IMPORT AlmaGenerator»

«EXTENSION templates::java::xJavaUtil»

«DEFINE Root FOR uml::Class»
    «EXPAND JavaComponent FOR this»
«ENDDEFINE»

«DEFINE JavaComponent FOR uml::Class»
    «FILE  getProyectName(this.package)+'/src/'+getPackagePath(this.package)+"/"+this.name+"Base.java"»
package «this.package.name»;

import java.util.logging.Level;
import java.util.logging.Logger;
import alma.ACS.ComponentStates;
import alma.acs.component.ComponentLifecycle;
import alma.acs.component.ComponentLifecycleException;
import alma.acs.container.ContainerServices;
import alma.ACSErrTypeCommon.CouldntPerformActionEx;
import alma.ACSErrTypeCommon.wrappers.AcsJCouldntPerformActionEx;
import alma.«getProyectName(this.package)».«this.name»BaseOperations;
«REM»Get the idl struct from the model, and add the to the imports«ENDREM»
«PROTECT CSTART '/*' CEND '*/' ID this.name+"."+"ProtectedImports"»
/* (non-javadoc!)
 * Autogenerated protected region, the imports in this protected area
 * are not generated, it's reserved to special features that they can't be
 * specified in the UML model
 */
«ENDPROTECT»
«REM»Get the idl struct from the model, and add the to the imports«ENDREM»
/* IDL Structs*/
«FOREACH this.eRootContainer.eContents.typeSelect(uml::Class) AS class-»
    «IF isIDLStruct(class)-»
import alma.«getProyectName(this.package)».«class.name-»;
    «ENDIF-»
«ENDFOREACH-»

/*Notification Channel*/
«IF isNCHybrid(this) -»
import alma.acs.nc.Consumer;
import alma.acs.nc.SimpleSupplier;
«ELSEIF isNCSupplier(this)-»
import alma.acs.nc.SimpleSupplier;
«ELSEIF isNCConsumer(this)-»
import alma.acs.nc.Consumer;
«ENDIF-»
«IF isNCHybrid(this) ||  isNCConsumer(this) ||  isNCSupplier(this)-»
import alma.«getProyectName(this.package)».testMessageBlockEvent;
«ENDIF-»

public class «this.name»Base «IF isInherited(this)» extends «getParentName(this)» «ENDIF»  implements ComponentLifecycle, «this.name»BaseOperations«IF haveInterfaces(this)»«FOREACH this.getImplementedInterfaces() AS interface», «interface.name»«ENDFOREACH-»«ENDIF»
{

    private ContainerServices m_containerServices;
    private Logger m_logger;
    «IF isNCConsumer(this) -»
    private Consumer m_consumer;
    «ELSEIF isNCSupplier(this)-»
    private SimpleSupplier m_supplier;
    «ELSEIF isNCHybrid(this)-»
     private Consumer m_consumer;
     private SimpleSupplier m_supplier;
     «ENDIF-»
    
    «PROTECT CSTART '/*' CEND '*/' ID this.name+"Base."+"ProtectedAttributes"»
	/* (non-javadoc!)
	 * Autogenerated protected region, the imports in this protected area
	 * are not generated, it's reserved for special features that they can't be
	 * specified in the UML model
	 */
	«ENDPROTECT»
    
    /* 
     * Implementation of  ComponentLifecycle
     */
    public void initialize(ContainerServices containerServices)  «IF !isInherited(this)»«IF isNCConsumer(this) || isNCSupplier(this) ||  isNCHybrid(this) -» throws ComponentLifecycleException «ENDIF-» «ENDIF-» {
    
        m_containerServices = containerServices;
        
        «IF isInherited(this)»
        super.initialize(containerServices);
        «ENDIF»
        
        m_logger = m_containerServices.getLogger();
        m_logger.info("initialize() called...");
        
         «IF isNCConsumer(this) -»
		  try
			{
		        m_consumer = new Consumer(alma.«getProyectName(this.package)».CHANNELNAME_DEFAULT«getProyectName(this.package).toUpperCase()»CHANNEL.value, m_containerServices);
				//Subscribe to a domain and event type.
				m_consumer.addSubscription(alma.«getProyectName(this.package)».testMessageBlockEvent.class, this);
				m_consumer.consumerReady();
				m_logger.info(" «this.name»  is waiting for 'testMessageBlockEvent' events.");
			}
			catch (Exception e)
			{
				if (m_consumer != null) {				
					m_consumer.disconnect();
				}
				/*
				 if uncomment the next line, add  throws ComponentLifecycleException, but first check if is inhitered class, can not be override the method.
				the generator put the right code.
				*/ 
				«IF isInherited(this)»//«ENDIF»throw new ComponentLifecycleException("failed to connect as an event consumer to channel " + alma.«getProyectName(this.package)».CHANNELNAME_DEFAULT«getProyectName(this.package).toUpperCase()»CHANNEL.value);
			}
	    «ELSEIF isNCSupplier(this)-»
	  try {
    		// Instantiate our supplier
    		m_supplier = new SimpleSupplier(alma.«getProyectName(this.package)».CHANNELNAME_DEFAULT«getProyectName(this.package).toUpperCase()»CHANNEL.value,
    				m_containerServices);
    	}
    	catch (Exception e) {
    		«IF isInherited(this)»//«ENDIF»throw new ComponentLifecycleException("failed to create SimpleSupplier for channel " + alma.«getProyectName(this.package)».CHANNELNAME_DEFAULT«getProyectName(this.package).toUpperCase()»CHANNEL.value, e);
    	}
	    «ELSEIF isNCHybrid(this)-»
	    try
			{
		        m_consumer = new Consumer(alma.«getProyectName(this.package)».CHANNELNAME_DEFAULT«getProyectName(this.package).toUpperCase()»CHANNEL.value, m_containerServices);
				//Subscribe to a domain and event type.
				m_consumer.addSubscription(alma.«getProyectName(this.package)».testMessageBlockEvent.class, this);
				m_consumer.consumerReady();
				m_logger.info(" «this.name»  is waiting for 'testMessageBlockEvent' events.");
			}
			catch (Exception e)
			{
				if (m_consumer != null) {				
					m_consumer.disconnect();
				}
				«IF isInherited(this)»//«ENDIF»throw new ComponentLifecycleException("failed to connect as an event consumer to channel " + alma.«getProyectName(this.package)».CHANNELNAME_DEFAULT«getProyectName(this.package).toUpperCase()»CHANNEL.value);
			}
			
			 try {
    		// Instantiate our supplier
    		m_supplier = new SimpleSupplier(alma.«getProyectName(this.package)».CHANNELNAME_DEFAULT«getProyectName(this.package).toUpperCase()»CHANNEL.value,
    				m_containerServices);
    	 }
    	 catch (Exception e) {
    		«IF isInherited(this)»//«ENDIF»throw new ComponentLifecycleException("failed to create SimpleSupplier for channel " + alma.«getProyectName(this.package)».CHANNELNAME_DEFAULT«getProyectName(this.package).toUpperCase()»CHANNEL.value, e);
    	}
	     «ENDIF-»
	     
	      «PROTECT CSTART '/*' CEND '*/' ID this.name+"."+"ProtectedAttributes"»
		/* (non-javadoc!)
		 * Autogenerated protected region, the imports in this protected area
		 * are not generated, it's reserved for special features that they can't be
		 * specified in the UML model
		 */
		«ENDPROTECT»
    }
    
     «IF isNCSupplier(this)»
     public void sendEvents() throws CouldntPerformActionEx
    {
    	m_logger.info("Now sending  testMessageBlockEvent events...");
        try {
            testMessageBlockEvent  event = new testMessageBlockEvent(Math.random(), "Event");
            m_supplier.publishEvent(event);
        }
        catch(Throwable thr) {
            m_logger.log(Level.WARNING, "failed to send testMessageBlockEvent. Will not try again.");
            throw (new AcsJCouldntPerformActionEx(thr)).toCouldntPerformActionEx();
        }
    }
     «ELSEIF isNCConsumer(this)-»
     public void receive(alma.«getProyectName(this.package)».testMessageBlockEvent event)
	{
	    m_logger.info("Received an event: " +event.message);
	}
     «ELSEIF isNCHybrid(this)-»
     
      public void sendEvents() throws CouldntPerformActionEx
     {
    	m_logger.info("Now sending  testMessageBlockEvent events...");
        try {
            testMessageBlockEvent  event = new testMessageBlockEvent(Math.random(), "Event");
            m_supplier.publishEvent(event);
        }
        catch(Throwable thr) {
            m_logger.log(Level.WARNING, "failed to send testMessageBlockEvent. Will not try again.");
            throw (new AcsJCouldntPerformActionEx(thr)).toCouldntPerformActionEx();
        }
    }
    
      public void receive(alma.«getProyectName(this.package)».testMessageBlockEvent event)
	 {
	    m_logger.info("Received an event: " +event.message);
	 }
     «ENDIF-»
     
    
    public void execute() {
        m_logger.info("execute() called...");
    }
    
    public void cleanUp() {
        m_logger.info("cleanUp() called...");
    }
    
    public void aboutToAbort() {
        cleanUp();
        m_logger.info("aboutToAbort() called...");
    }
    
    /* 
     * Implementation of ACSComponent
     */
    public ComponentStates componentState() {
        return m_containerServices.getComponentStateManager().getCurrentState();
    }
    
    public String name() {
        return m_containerServices.getName();
    }
    
    /* 
     * Definition of member «this.name»Operations
     */
  
    «FOREACH this.getOperations() AS operation-»
    public «getJavaReturnType(operation)» «operation.name-»(«FOREACH operation.ownedParameter.select(e|e.direction.toString()!= 'return') AS param SEPARATOR ', '-»«getJavaParam(param)» «param.name»«ENDFOREACH-») 
    {
    	«PROTECT CSTART '/*' CEND '*/' ID this.name+"."+operation.name»
    «IF ! isVoid(operation)»return «getReturnValue(operation)»;«ENDIF»   
    	«ENDPROTECT»   
    }
    
    «ENDFOREACH-»
    «IF isOverride(this) &&  !isAllOverride(this) -»
	«EXPAND JavaInheritanceOverride::Root FOR this-» 
	«ELSEIF isAllOverride(this)-»
	«EXPAND JavaInheritanceAllOverride::Root FOR this-» 
	«ENDIF-»
	«IF haveInterfaces(this)-»
	«EXPAND JavaInterfaceImplements::Root FOR this-» 
	«ENDIF-»
	
	«PROTECT CSTART '/*' CEND '*/' ID this.name+"."+"ProtectedRegion"»
	/* (non-javadoc!)
	 * Autogenerated protected region, the implementations in this protected area
	 * are not generated, it's reserved to special features that they can't be
	 * specified in the UML model
	 */
    «ENDPROTECT»
}
  «ENDFILE»
«ENDDEFINE»
    